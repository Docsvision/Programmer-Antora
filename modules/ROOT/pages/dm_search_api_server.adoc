= Серверный поиск

Поисковый запрос для выполнения серверного поиска описывается строкой в формате XML. Он строится по специальной схеме (Search.xsd), которая описывает все возможные комбинации условий поиска.

Конкретный XML поискового запроса может быть получен, например, при помощи визуального редактора (диалог «Расширенный поиск» в Windows-клиенте), где пользователь может оперировать семантически значимыми понятиями, такими как _тип карточки – секция – поле – значение_. Но результатом работы этого визуального редактора все равно в конечном счете станет XML-строка запроса, которая и будет передана на сервер для выполнения. Этот XML-текст может быть скопирован из диалога и использован в коде для выполнения аналогичных запросов.

Также текст поискового запроса может быть задан программно – например, при помощи набора стандартных объектов для работы с XML (XML Parser). Однако, для упрощения программного создания и редактирования запросов, в объектной модели [.keyword .apiname]#ObjectManager# предусмотрен ряд специализированных объектов.

image::tj_search_1.png[[.fig--title-label]##Рис. 1. ##Структура запроса]

Все объекты для работы с поиском расположены в выделенном пространстве имен *DocsVision.Platform.ObjectManager.SearchModel*, поэтому для их использования нужно подключить данное пространство имен к проекту.

Базовым объектом для построения поискового запроса является объект xref:api/DocsVision/Platform/ObjectManager/SearchModel/SearchQuery_CL.adoc[SearchQuery]. Для создания этого объекта, предназначен специальный метод xref:api/DocsVision/Platform/ObjectManager/UserSession.CreateSearchQuery_MT.adoc[CreateSearchQuery] пользовательской сессии (UserSession).

Сам запрос состоит из двух частей - атрибутивного поиска (*AttributiveSearch*) и полнотекстового запроса (*FullTextSearch*). Эти части независимы друг от друга и могут фигурировать в запросе как по отдельности, так и одновременно. Возможно объединение результатов этих частей по И/ИЛИ, для этого предназначен флаг *CombineResults*.

Количество карточек в результатах поиска можно ограничить свойством *Limit*.

Пространство карточек, на котором исполняется запрос, ограничивается объектом *Scope*. Это ограничение накладывается и на атрибутивную, и на полнотекстовую части запроса и может включать в себя ограничение по конкретным типам карточек (*CardTypes*) и по папкам, в которых расположены ярлыки карточек (*Folders*).

[source,csharp]
----
SearchQuery query = session.CreateSearchQuery();
 
 // Установка ограничения по типам карточек
query.Scope.CardTypes.AddNew(new Guid("C1FED883-08DE-420F-8FB4-C16CEFFC1630"));
query.Scope.CardTypes.AddNew(new Guid("FA0C389E-1095-4BC1-BEDC-793463742571"));
   
// Установка ограничения по папкам
query.Scope.Folders.AddNew(new Guid("C0BCEB41-A19B-4813-A355-82EB6FD4F5F0")).IncludeSubfolders = true;
----

Отменить наложенные ограничения может свойствo *AllCards* – при его установке поиск производится по всем карточкам, независимо от указанных ограничений.

Свойство *IncludeLinkedCard* позволяет включить в результаты поиска карточки, связанные с уже найденными по ссылкам на определённую глубину вложенности (глубина задается в качестве значения свойства). Дополнительно можно ограничить тип ссылок (*LinkTypes*) и их направление (*LinkDirections*).

Сходное по действию свойство *IncludeTopicCards* позволяет включить в результаты поиска карточки, принадлежащие к одной теме обработки с найденными.

Признак *IncludeArchived* сигнализирует о необходимости включать в область поиска также и все архивные карточки. Аналогичный признак *IncludeDeleted* позволяет искать в том числе и в удаленных карточках.

Чтобы получить сформированную строку запроса в формате XML надо воспользоваться методом *GetXml().* В этом методе параметр __ForSearch=__**+++true+++** означает, что строка формируется с целью отправки на сервер, и не должна содержать неактивные настройки (например, такие, как поисковые слова). Значение __ForSearch=__**+++false+++** означает, что строка получается для сохранения где-либо и поэтому в неё включаются все настройки поиска. Второй параметр метода — *Parameters* – содержит массив значений, которые будут подставлены на место параметров, заданных в поиске.

Существует также обратный метод – *ParseXml*(**+++string+++**__queryXml__). С его помощью можно проинициализировать объект *SearchQuery* из сохраненной строки XML-запроса.

Полнотекстовая часть поискового запроса (*FullTextSearch*) очень проста и позволяет задать только саму строку для поиска (*QueryString*) и режим поиска (*Mode*), чтобы ограничить поиск только файлами или всеми карточками. Поиск возможен только по карточкам, для которых в схеме разрешен поиск. В результате поиска по файлам будут возвращены карточки-владельцы найденных файлов, а не сами файлы.

Пример кода построения полнотекстового запроса:

[source,csharp]
----
SearchQuery query = session.CreateSearchQuery();

// Условия полнотекстового поиска
query.FullTextSearch.QueryString = "Договор на обслуживание";
query.FullTextSearch.Mode = FullTextSearchMode.Files;
----

Атрибутивная часть описывает условия на значения полей карточек, которые требуется найти. Она состоит из запросов к карточкам (*CardTypeQuery*). Если требуется найти все карточки, следует выставить в *+++true+++* параметр AllCards. Каждый запрос к типу карточки состоит из набора запросов к секциям карточки (*SectionQuery*).

image::tj_search_2.png[[.fig--title-label]##Рис. 2. ##Структура атрибутивного поиска]

Каждый запрос к секции состоит из набора условий (*Condition*), накладываемых на конкретные поля секции. Условия организуются в иерархические группы (*ConditionGroup*). Группа условий — это аналог скобок в выражении. Условия внутри *ConditionGroup* объединяются операцией (И/ИЛИ), задаваемой свойством *Operation*. Группы *ConditionGroup* могут быть вложенными.

image::tj_search_3.png[[.fig--title-label]##Рис. 3. ##Структура поиска по секции]

Сформированный поисковый запрос можно выполнить, вызвав метод *CardManager.FindCards* (в параметре метода передается XML-строка сформированного запроса). Метод возвращает *CardDataCollection* – коллекцию найденных карточек, соответствующих условиям запроса. Если же в результате выполнения запроса не было найдено ни одной карточки – коллекция будет пуста.

В качестве примера рассмотрим построение запроса, который вернёт все карточки типа «Документ», у которых название равно «Sample». Перед тем как строить запрос, необходимо выяснить идентификаторы типа карточки, который собираемся искать, а также идентификаторы секций, в полях которых производится поиск. Целесообразно оформить эти идентификаторы в виде констант:

[source,csharp]
----
const string ID_CARDTYPE = "{B9F7BFD7-7429-455E-A3F1-94FFB569C794}";
const string ID_SECTION = "{30EB9B87-822B-4753-9A50-A1825DCA1B74}";

SearchQuery searchQuery = userSession.CreateSearchQuery();

//Поиск по типу карточки    
CardTypeQuery typeQuery = searchQuery.AttributiveSearch.CardTypeQueries.AddNew(new Guid(ID_CARDTYPE));

//Поиск по секции
SectionQuery sectionQuery = typeQuery.SectionQueries.AddNew(new Guid(ID_SECTION));

//Поиск по значению поля
sectionQuery.ConditionGroup.Conditions.AddNew("Name", FieldType.Unistring, ConditionOperation.Equals, "Sample");

//Получение текста запроса
string query = searchQuery.GetXml();

//Выполнение запроса    
CardDataCollection coll = userSession.CardManager.FindCards(query);
----

В результате будет выполнен следующий запрос (см. содержимое переменной `query`):

[source,csharp]
----
<Search Version="4300" CombineResults="OR">
 <AttributiveSearch>
  <CardTypeQuery CardTypeID="{B9F7BFD7-7429-455E-A3F1-94FFB569C794}">
   <SectionQuery Version="4300" SectionTypeID="{30EB9B87-822B-4753-9A50-A1825DCA1B74}">
    <ConditionGroup Alias="alias0" Operation="OR">
     <Condition Alias="alias1">
      <Field FieldType="unistring">Name</Field> 
      <Op>EQ</Op> 
      <Value>'Sample'</Value> 
     </Condition>
    </ConditionGroup>
    <Options Limit="-1" /> 
   </SectionQuery>
  </CardTypeQuery>
 </AttributiveSearch>
 <Scope /> 
 <FulltextSearch Mode="CardsAndFiles">
  <QueryString /> 
 </FulltextSearch>
</Search>
----

При построении условий к секциям можно также использовать присоединенные секции (*JoinSections*). Такая необходимость может возникнуть, если поле, по которому нужно искать, физически содержится в секции другой карточки. В этом случае к запросу по секции (*SectionQuery*) нужно присоединить секцию связанной карточки (*JoinSections.AddNew*). Для присоединённой секции (*JoinSection*) необходимо указать псевдоним (*Alias*), поле секции, по которому идёт соединение (*SectionField*), а также идентификатор (*ID*) или псевдоним (*JoinWith*) присоединяемой секции или системной таблицы (*TableName*) и имя её поля (*WithField*). А в самом условии (*Condition*) необходимо, помимо имени поля, задать также псевдоним секции (*SectionAlias*), которому это поле принадлежит.

Пример: основная секция карточки, по которой строится запрос, содержит поле Регистратор – представляющее собой ссылку (*REF_ID*) на запись о сотруднике (из справочника сотрудников) и нужно найти все карточки, у которых E-Mail регистратора содержит подстроку «mail.ru». Такие детали, как E-Mail сотрудника, хранятся только в соответствующей секции справочника сотрудников – поэтому её необходимо присоединить при построении такого запроса:

[source,csharp]
----
//Идентификатор секции справочника сотрудников
const string REFSTAFF_EMPLOYEES = "{DBC8AE9D-C1D2-4D5E-978B-339D22B32482}";

//Присоединение секции справочника сотрудников
JoinSection join = sectionQuery.JoinSections.AddNew("RegisteredBy_Info");
join.Id = new Guid (REFSTAFF_EMPLOYEES);
join.SectionField = "RowID";
join.WithField = "RegisteredBy";

//Добавление условия на поле присоединенной секции
Condition condition = sectionQuery.ConditionGroup.Conditions.AddNew("Email", FieldType.Unistring, ConditionOperation.EndsWith, "mail.ru");
condition.SectionAlias = "RegisteredBy_Info";
----

Таким образом, при построении запросов можно использовать следующий несложный алгоритм:

. Создать новый объект запроса (*SectionQuery*)
. При необходимости – установить ограничения области поиска (*Scope*) на типы карточек (*CardTypes*) и папки (*Folders*).
. Если запрос полнотекстовый – то задать строку поиска (*FullTextSearch.QueryString*).
. Если запрос содержит атрибутивные условия:
[loweralpha]
.. Определить тип карточки, которая должна являться результатом поиска (*CardTypeQuery*).
.. Определить, по какой секции карточки строится запрос (*SectionQuery*). Если поле, по которому производится поиск, физически находится в секции другой (связанной) карточки – то присоединить её (*JoinSections*).
.. Сформировать как минимум одну группу условий (*ConditionGroup*) и определить операцию для условий (*Operation*).
.. Добавить в группу условия (*Condition*), для каждого их которых:
[lowerroman]
... Определить имя поля, по которому производится сравнение (*FieldAlias*) и его тип (*FieldType*), а если поле принадлежит связанной секции – то имя этой секции (*SectionAlias*).
... Определить условие (*Operation*).
... Определить значение для сравнения (*Value*).
... Если условие использует агрегацию, то:
.... задать имя функции (AggregateFunctionName);
.... при необходимости, задать дополнительные условия на агрегируемые значения (AggregateConditionGroup).
. Выполнить запрос (*CardManager*.*FindCards*).

Помимо поиска экземпляров карточек, объектная модель может использоваться и для поиска строк в конкретной секции карточки. Для этого предназначен метод *SectionData.FindRows*, который возвращает коллекцию строк (*RowDataCollection*), соответствующих условиям запроса, или пустую коллекцию, если ни одна строка не подходит.

Текст запроса для поиска строк соответствует аналогичному запросу для поиска карточек, но в несколько «урезанном» варианте – он начинается сразу с уровня объекта *SectionQuery*, который также является создаваемым при помощи соответствующего метода объекта UserSession:

[source,csharp]
----
SectionQuery secQuery = session.CreateSectionQuery();
----

[NOTE]
====
[.note__title]#Прим.:# Очевидно, для поиска строк секций могут использоваться только атрибутивные (а не полнотекстовые) условия.
====

При построении поисковых запросов внутри секции можно пользоваться всеми возможностями поисковой модели – присоединенными секциями, агрегациями, и т.д. Для этого используются те же самые объекты.

В приведенном далее примере выполняется поиск всех строк в справочнике сотрудников c фамилией Иванов:

[source,csharp]
----
const string REFSTAFF_CARDTYPE = "6710B92A-E148-4363-8A6F-1AA0EB18936C";
const string REFSTAFF_EMPLOYEES = "DBC8AE9D-C1D2-4D5E-978B-339D22B32482";

// Получение данных справочника
CardData staffData = session.CardManager.GetDictionaryData(new Guid(REFSTAFF_CARDTYPE));

// Получение секции сотрудников
SectionData section = staffData.Sections[new Guid(REFSTAFF_EMPLOYEES)];

// Создание поискового запроса по секции
SectionQuery query = session.CreateSectionQuery();

// Условие по полю фамилия
query.ConditionGroup.Conditions.AddNew("LastName", FieldType.Unistring, ConditionOperation.Equals, "Иванов");

// Выполнение запроса
RowDataCollection results = section.FindRows(query.GetXml()); 
----

== См. также

* xref:dm_search_api_filter.adoc[Клиентская фильтрация]
