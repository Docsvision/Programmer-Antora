= Работа с правами доступа

Система позволяет назначать права на отдельные объекты, для чего используется система безопасности Windows, основанная на пользователях и группах (доменных или локальных) и описателях прав (дескрипторах).

Право дается или запрещается пользователю при помощи объекта ACE (`access control entry`), который задаёт маску прав. Права могут быть даны (`allowed`) или запрещены (`denied`) конкретному пользователю или группе (`security principal`).

ACE объединяются в список ACL (`access control list`). DACL (`discretionary access control list`) хранится в описателе прав (`security descriptor`), в котором, кроме списка DACL, есть ещё информация о владельце объекта (`owner`), а также настройки аудита в виде списка SACL (`system access control list`). Кроме того, начиная с версии 4.3, поддерживается использование в дескрипторе метки уровня доступа (`mandatory access control, MAC`).

[NOTE]
====
В текущей версии платформы аудит не поддерживается.
====

Права, которые можно настраивать на объектах, делятся на общие (`general`) и специфические (`specific`). Общие отображаются в главном диалоге настройки безопасности. Специфические появляются в списке в окне _Advanced_. Общие права используются для упрощения администрирования. Специфические права дают администратору возможность управлять поведением объектов на более тонком уровне.

.Общие права (`AccessGeneral`) состоят из набора частных прав:
* Чтение (`R`, `RP`).
* Изменение (`W`, `CC`, `DC`).
* Удаление (`D`).
* Полный доступ (все права).

.Специфические права (`AccessSpecific`):
* Чтение данных объекта (`R`).
* Изменение данных объекта (`W`).
* Создание дочерних объектов (`CC`).
* Удаление дочерних объектов (`DC`).
* Удаление объекта (`D`).
* Чтение разрешений (`RP`).
* Изменение разрешений (`SP`).
* Смена владельца (`TO`).

.Система позволяет назначать права на все низкоуровневые объекты:
* Типы карточек (`xref:Platform-ObjectManager-Metadata:CardType_CL.adoc[CardType]`).
* Карточки (`xref:Platform-ObjectManager-CardData:CardData_CL.adoc[CardData]`).
* Секции (`xref:Platform-ObjectManager-SectionData:SectionData_CL.adoc[SectionData]`).
* Строки (`xref:Platform-ObjectManager-Row:RowData_CL.adoc[RowData]`).
* Файлы (`xref:Platform-ObjectManager-ILockable:FileData_CL.adoc[FileData]`).
* Хранимые процедуры (`xref:Platform-ObjectManager-Report:Report_CL.adoc[Report]`).
* Пользовательские объекты.

Для этого в каждом из этих объектов предусмотрено два специальных метода: `GetAccessControl` -- возвращающий описатель прав и `SetAccessControl`, устанавливающий описатель прав.

== Наследование прав

В системе реализовано наследование прав от родительских к дочерним объектам следующим образом:

* Карточка наследует права от других карточек, которые держат на данную карточку сильные ссылки (а физически от строки, в которой содержится ссылка). При установке первой сильной ссылки на карточку её права меняются, чтобы отразить включившееся наследование. При изменении прав на родительскую карточку права на подчинённую карточку меняются соответственно.
* Секция карточки наследует от экземпляра карточки, которому он принадлежит, или от родительской строки если это подчинённая секция.
* Строка наследует права от своей секции.
* Файл наследует от карточки владельца, если она задана.

Частным, но важным случаем является наследование прав от папки на карточку. Папка -- это строка в карточке папок -- от неё права наследуют все ярлыки в папке. По сильным ярлыкам права переходят на карточки. Таким образом, права на карточки, на которые существуют сильные ярлыки, наследуются от карточки папок.

В {wincl}е права на карточку папок могут быть отредактированы на узле _Папки_. Данный частный случай относится только к {dv} 4.5. В {dv} 5 ярлык является слабой ссылкой -- дискреционные права, установленные для папки, не будут унаследованы карточками, ярлыки на которые размещены в папке.

.Наследованием прав можно управлять при помощи специальных флагов, определяющих порядок наследования:
* `ContainerInheritAce` -- права распространяются на дочерние контейнеры;
* `ObjectInheritAce` -- права распространяются на дочерние объекты;
* `InheritOnlyAce` -- права распространяются только на потомков, но не на сам объект.

Таким образом, возможные сочетания этих флагов определяют многообразие типов наследования прав:

[cols=",",options="header"]
|===
|Кто наследует |Сочетание флагов

|Этот объект, дочерние контейнеры и объекты
a|`ContainerInheritAce`

`ObjectInheritAce`

|Этот объект и дочерние контейнеры
|`ContainerInheritAce`

|Этот объект и дочерние объекты (не контейнеры)
|`ObjectInheritAce`

|Только дочерние контейнеры и объекты
a|`ContainerInheritAce`

`ObjectInheritAce`

`InheritOnlyAce`

|Только дочерние контейнеры
a|`ContainerInheritAce`

`InheritOnlyAce`

|Только дочерние объекты (не контейнеры)
a|`ObjectInheritAce`

`InheritOnlyAce`

|Только этот объект
|
|===

[NOTE]
====
*Все* стандартные объекты системы (карточки, секции, строки) являются *контейнерами* и именно в таком качестве рассматриваются при наследовании прав.
====

== Программное назначение прав

Объекты связанные с реализацией модели безопасности расположены в специальном пространстве имён -- `DocsVision.Platform.Security.AccessControl`, которое реализовано в отдельной сборке -- `DocsVision.Platform.dll`. Поэтому для работы с безопасностью, эту сборку следует предварительно подключить к своему проекту, а также определить используемое пространство имён:

[source,csharp]
----
using DocsVision.Platform.Security.AccessControl;
----

Классы для работы с правами карточек, файлов, и хранимых процедур унаследованы от базового класса `xref:Platform-Security:AccessControl/DVObjectSecurity_CL.adoc[DVObjectSecurity]`, который содержит основные механизмы для работы с правами. Кроме этого, каждый из них содержит ряд специфических свойств, характерных именно для данного объекта (схемы прав). Этот класс по сути дела описывает дескриптор (`SD`), и включает в себя методы для работы с разрешениями (`ACE`), аудитами, и другими свойствами дескриптора.

[NOTE]
====
Обращаем внимание, что численные значения некоторых элементов перечислений, описывающих права доступа были изменены относительно {dv} 4.х. И в случае, если в системе имеется унаследованное от {dv} 4.x решение, в котором работа с флагами прав доступа осуществлялась через использование целочисленных констант, а не через использование вышеописанных перечислений, то рекомендуется проверить соответствие использованных целочисленных констант актуальным значениям перечислений.
====

Общий алгоритм работы с правами в рамках данной модели можно сформулировать следующим образом:

.Чтобы добавить новое разрешение на карточку, файл или процедуру необходимо:
. Получить объект для работы с разрешениями `xref:Platform-ObjectManager-CardData:CardData.GetAccessControl_MT.adoc[CardData.GetAccessControl]`
. Создать новое разрешение `xref:Platform-Security:AccessControl/CardDataAccessRule_CL.adoc[CardDataAccessRule]` с необходимыми атрибутами.
. Добавить разрешение к описателю прав `xref:Platform-Security:AccessControl/CardDataSecurity.AddAccessRule_MT.adoc[AddAccessRule]` или `xref:Platform-Security:AccessControl/CardDataSecurity.SetAccessRule_MT.adoc[SetAccessRule]`.
. Сохранить изменённый описатель прав `xref:Platform-ObjectManager-CardData:CardData.SetAccessControl_MT.adoc[SetAccessControl]`.
+
В примере, для существующей карточки с идентификатором `00000000-0000-0000-0000-000000000000` добавляются права на чтение для пользователя `IvanovII`.
+
[source,csharp]
----
CardData card = userSession.CardManager.GetCardData(new System.Guid("00000000-0000-0000-0000-000000000000")); <.>

CardDataSecurity cardDataSecurity = card.GetAccessControl(); <.>

CardDataAccessRule cardDataAccessRule = new CardDataAccessRule("DOMAIN\\IvanovII", CardDataRights.Read, AccessControlType.Allow); <.>

cardDataSecurity.SetAccessRule(cardDataAccessRule); <.>

card.SetAccessControl(cardDataSecurity); <.>
----
<.> Получение с сервера данных карточки с известным идентификатором.
<.> Получение описателя прав карточки.
<.> Создание нового разрешения -- совокупного права чтения.
<.> Добавление нового разрешения к описателю прав.
<.> Сохранение изменённого описателя прав.

.Чтобы удалить разрешения на карточку, файл или процедуру, необходимо:
[start=5]
. Получить объект для работы с разрешениями `CardData.GetAccessControl`.
. Удалить разрешения для субъекта:
.. Vетодом http://msdn.microsoft.com/ru-ru/library/system.security.accesscontrol.objectsecurity.purgeaccessrules.aspx[`PurgeAccessRules`], чтобы удалить *все* разрешения для субъекта
.. Vетодом `xref:Platform-Security:AccessControl/CardDataSecurity.RemoveAccessRuleSpecific_MT.adoc[RemoveAccessRuleSpecific]`, чтобы удалить конкретное разрешение для субъекта.
.. Методом `SetAccessRule`, чтобы удалить все разрешения для субъекта и добавить вместо них новое.
. Сохранить изменённый описатель прав `SetAccessControl`.
+
Ниже приведён пример, в котором у пользователя `IvanovII` отбираются права на карточку с идентификатором `00000000-0000-0000-0000-000000000000`.
+
[source,csharp]
----
CardData card = userSession.CardManager.GetCardData(new System.Guid("00000000-0000-0000-0000-000000000000"));
CardDataSecurity cardDataSecurity = card.GetAccessControl();

cardDataSecurity.PurgeAccessRules(new NTAccount("DOMAIN\\IvanovII")); <.>

card.SetAccessControl(cardDataSecurity); <.>
----
<.> Удаление всех прав пользователя.
<.> Сохранение изменённого описателя прав.

[NOTE]
====
Значения битовых флагов стандартных прав приведены в таблице: xref:appendix:permission-flags.adoc["Битовые флаги стандартных прав доступа"]
====
